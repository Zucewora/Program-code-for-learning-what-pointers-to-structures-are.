#include <iostream>

using namespace std;

// объявим структуру
struct elem
{
	int value;   // хранимое целое значение
	elem* next; // ссылка на следующий элемент (это адрес. возможно, пустой - NULL)
};

// тут мог бы быть метод добавления элемента в список такой, чтобы в списке все значения шли по возрастанию

// тут мог бы быть метод, который искал бы ссылку на структуру с этажом с нужным номером и/или на структуру с последним этажом с номером меньшим, чем образец
//bool GetLinkToElementNumber(elem* start, int valueofinterest, elem*& result/*это ссылка на переменную, которую метод должен заполнить*/)
//результат будет false, если список пустой либо если мы не нашли в списке структуры с интересующим нас значением 

// Дано: ссылка на начало списка, номер желаемого элемента, адрес найденного элемента. Ответ: достали или нет (успех/неудача извлечения элемента)
bool GetLinkToElementNumber(elem* start, int index, elem*& result/*это ссылка на переменную, которую метод должен заполнить*/)
// main передаст в этот метод(функцию) ПО ССЫЛКЕ (&) переменную result типа "указатель на elem". Этот метод заполнит указатель, и main получит его по ссылке по окончании метода GetLinkToElementNumber
// Если передать elem* result, то создастся копия переданного значения, и функция изменит копию => main не увидит изменений в result
// Как раз start передаётся как копия: на бумажке записали адрес, по кот.нужно что-то проверить, и отдали записку в функцию (тут main не ожидает изменений значения start)
{
	result = NULL; // пока что элемент не найден => адрес пуст
	bool success = start != NULL; // если указатель на начало списка не пуст, то есть с чем работать
	if (success)
	{
		// Пусть текущая ссылка - current
		elem* current = start; // это текущая ссылка

		// она пока что совпадает со ссылкой start -- ссылка на структуру (4 Байта - адрес, а в 64-битной ОС - 8Б)

		for (int i = 0; i < index; i++)
		{
			if (current->next != NULL) // если в структуре, которая (вон там, по адресу, хранимому в current), в поле next
										 // лежит НЕ пустой адрес, то мы заменяем адрес в переменной current на найденный (то есть
										 // продвигаемся по ссылке вперёд на одно звено цепи => теперь у нас новый текущий элемент по адресу current)
			// второй вариант того же условия: if ((*current).next != NULL)
			{
				// Достаём следующую ссылку (след.звено нашей цепи):
				// 1) прошли по адресу, хранящемуся в current: (*current) , дошли до значения (самой структуры)"
				// 2) дошли до структуры, достали из неё поле next - это ссылка
				// 3) сохранили ссылку в поле типа ссылка (типы current и next совпадают)
				current = (*current).next;
				// типы current и next совпадают
			}
			else
			{
				// если же там лежит пустой адрес, то мы не дойдём до искомого элемента по номеру, их не хватает => неудача
				success = false;
				break;
			}
		}
		if (success) // всё ещё не было ошибки
		{
			// заполняем переменную result типа указатель: кладём туда указатель
			result = current; // ссылка, которую мы нашли
		}
	}
	return success; // если не удалось, то в result будет NULL, иначе в result будет ссылка на найденный элемент

	/* Пример:
	Элементы: start -> 10 -> 20 -> 30 -> 40
	Их номера: -- 0 -- 1 -- 2 -- 3

	start - это адрес начального элемента - структуры, где 10

	Хранение: (адрес элемента с 10) -> {10, (адрес элемента с 20)} -> {20, (адрес элемента с 30)} -> {30, (адрес элемента с 40)} -> {40, NULL(пустой адрес)}

	Если нужна ссылка на 3й элемент, нужно пройти 3 шага из точки старта:
	0) дойти (вон туда) до 0го элемента, взять из него ссылку на 1й
	1) дойти (вон туда) до 1го элемента, взять из него ссылку на 2й
	2) дойти (вон туда) до 2го элемента, взять из него ссылку на 3й
	это она

	В примере мы сделали три шага, номер шага от 0 до 2, 2 = 3-1
	=> for (int i = 0; i < index; i++)
	*/
}

int GetCount(elem* start)
{
	int result = 0;
	bool success = start != NULL;
	if (success)
	{
		// напишите подсчёт количесвта элементов по ссылке, которая в 1м аргументе этого метода
	}
	return result;
}


int main()
{
	setlocale(LC_ALL, "Russian");

	// это указатель на начало списка элементов
	elem* start; // сейчас (start - мусор), а если записать start = NULL, то список указывает в пустоту

	/* тут код для мук с памятью
	elem thisisastruct = new elem; // выделяю память в стеке (статическая память, мы её не освобождаем!! последний delete делать нельзя!)
	thisisastruct.next = NULL; // пустой адрес: за этим элементом нет следующего
	thisisastruct.value = 0; // это можно считать через cin

	start //значение в (переменной типа ссылка)
		= &thisisastruct; // ссылка на эту структуру (ссылка на значение типа elem, то есть адрес памяти, где хранится thisisastruct)

		Эти закомментированные строки выделяют память для thisisastruct как статическую, а аналогичные 4 строки ниже -- как динамическую.
		Если заменить активный код на этот закомментированный, нужнуы будут два патча, которые закомментированы ниже с тем же заголовком, чтобы не было ошибок работы
	*/

	elem* thisisastruct = new elem; // выделяем память в области динамической памяти (в куче) 1шт
	(*thisisastruct).next = NULL; // пустой адрес: за этим элементом нет следующего
	(*thisisastruct).value = 0; // это можно считать через cin

	start /*значение в (переменной типа ссылка)*/ = thisisastruct /* (значение типа ссылка)*/; // итог: две перменные хранят один и тот же адрес (смотрят на одну и ту же запись)

	int IndexOfLastElement = 0;
	elem* current = NULL; // это ТЕКУЩИЙ элемент
	// Выделяем память для current, чтобы передать внутрь метода GetLinkToElementNumber адрес, ПО КОТОРОМУ нужно положить ответ

	cout << "Точка старта - указатель на начальный элемент списка - хранит адрес " << (void*)(start) << "\n";
	/* тут код для мук с памятью
	cout << "Элемент №\t" << 0 << "... значение\t" << thisisastruct.value <<
			", \tадрес следующего: " << (void*)(thisisastruct.next) << "..."; */
	cout << "Элемент №\t" << 0 << "... значение\t" << (*thisisastruct).value <<
		", \tадрес следующего: " << (void*)((*thisisastruct).next) << "...";
	cout << "\nЗаполняю список...\n";
	for (int i = 1; i <= 5; i++)
	{
		elem* MemoryWhichExistsOnlyInThisStepOfCycle = new elem;
		(*MemoryWhichExistsOnlyInThisStepOfCycle).next = NULL;
		(*MemoryWhichExistsOnlyInThisStepOfCycle).value = i * 10; // это можно считать через cin

		cout << "Создаю запись: получена память по адресу " << (void*)(MemoryWhichExistsOnlyInThisStepOfCycle) <<
			", значение \t" << (*MemoryWhichExistsOnlyInThisStepOfCycle).value <<
			", \t адрес следующего: " << (void*)((*MemoryWhichExistsOnlyInThisStepOfCycle).next) << "\n";

		// вызов функции, которая достанет адрес (i-1)го элемента списка: MemoryWhichExistsInCycleAndAfterCycle
		bool f = GetLinkToElementNumber(start, IndexOfLastElement, current);
		cout << "Извлекаю элемент №\t" << i - 1 << "... ";

		// на 1м шаге f == start
		if (!f)
		{
			// что-то произошло, элемент не найден, напишем об этом в cout
			cout << "Не удалось получить ссылку на элемент!\n";
			system("pause");
			break;
		}
		else
		{
			cout << "есть, значение \t" << (*current).value;
			cout <<
				", \t адрес следующего: " << (void*)((*current).next);
			cout <<
				"...заменяю на " << (void*)(MemoryWhichExistsOnlyInThisStepOfCycle) << ", готово\n";

			// в поле next от записи, которая (по адресу MemoryWhichExistsInCycleAndAfterCycle), записать адрес новой записи
			(*current).next = MemoryWhichExistsOnlyInThisStepOfCycle;
			IndexOfLastElement++;

			cout << "Теперь элемент № " << i - 1 << " смотрит на запись № " << i << " со значением " <<
				(*(*current).next).value << "\n\n";
			//cout << "значение \t" << (*current).value <<
			//", \t адрес следующего: " << (*current).next << "...";
		}
	}

	cout << "\n\nОчистка памяти из конца в начало:\n";
	bool f2;
	for (int j = IndexOfLastElement; j >= 0; j--)
	{
		// чистить память нужно от каждого адреса
		f2 = GetLinkToElementNumber(start, j, current); // повторно используем переменную current
		if (!f2)
		{
			// что-то произошло, элемент не найден, напишем об этом в cout
			cout << "Не удалось получить ссылку на элемент!\n";
			system("pause");
			break;
		}
		else
		{
			cout << "Извлекаю элемент №\t" << j << "... хранится по адресу " << (void*)(current) << ": значение \t" << (*current).value <<
				", \t адрес следующего: " << (void*)((*current).next) << "...";

			/* код для мук с памятью
			if (j > 0) // если j==0, а я выделяла память так: "elem thisisastruct = new elem", тогда thisisastruct - это кусочек статической памяти, его нельзя освобождать*/
			delete current;

			cout << "очищена запись\n";
		}
	}
	// на последнем шаге м, а если у нас только один адрес start, то достаточно его стереть так: delete start;
	cout << " Готово!\n";
	system("pause");
	return 0;
}
